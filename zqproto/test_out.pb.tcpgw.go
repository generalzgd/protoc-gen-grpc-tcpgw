// Code generated by protoc-gen-grpc-tcpway. DO NOT EDIT.
// source: imgate.proto

/*
Package zqproto is a tcp/ws proxy.

It translates protobuf/Json packet into gRPC APIs.
*/
package zqproto

import (
	"context"
	"encoding/json"
	"errors"
	"strings"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// define func
type registerHandler func(args *TransmitArgs) (err error)

type transmit_Authorize_Handler func(*TransmitArgs, AuthorizeClient) (proto.Message, error)

type transmit_Im_Handler func(*TransmitArgs, ImClient) (proto.Message, error)

type TransmitArgs struct {
	Method      string
	Endpoint    string
	MD          metadata.MD
	Data        []byte
	Codec       uint16
	Opts        []grpc.DialOption
	EndCallback func(proto.Message)
	ctx         context.Context
}

var (
	// tag @id to package.TargetService/Method map
	id2meth = map[uint16]string{}

	transmit_Authorize_Map = map[string]transmit_Authorize_Handler{}

	transmit_Im_Map = map[string]transmit_Im_Handler{}

	serviceMap = map[string]registerHandler{}
)



func init() {
	// todo something missing

	transmit_Authorize_Map["zqproto.Authorize/Login"] = request_Authorize_Login

	transmit_Authorize_Map["zqproto.Authorize/GetUserInfo"] = request_Authorize_GetUserInfo

	transmit_Im_Map["zqproto.Im/Read"] = request_Im_Read

	transmit_Im_Map["zqproto.Im/Send"] = request_Im_Send

	transmit_Im_Map["zqproto.Im/Get"] = request_Im_Get

	transmit_Im_Map["zqproto.Im/Delete"] = request_Im_Delete

	transmit_Im_Map["zqproto.Im/UpdateConversation"] = request_Im_UpdateConversation

	transmit_Im_Map["zqproto.Im/Black"] = request_Im_Black

	transmit_Im_Map["zqproto.Im/GetUnreadCount"] = request_Im_GetUnreadCount

	transmit_Im_Map["zqproto.Im/GetBlockList"] = request_Im_GetBlockList

	transmit_Im_Map["zqproto.Im/SetRecvFactor"] = request_Im_SetRecvFactor

	transmit_Im_Map["zqproto.Im/GetRecvFactor"] = request_Im_GetRecvFactor

	serviceMap["zqproto.Authorize"] = register_Authorize_Transmitor

	serviceMap["zqproto.Im"] = register_Im_Transmitor

}

func decodeBytes(data []byte, codec uint16, inst proto.Message) error {
	if codec == 0 {
		if err := proto.Unmarshal(data, inst); err != nil {
			return err
		}
	} else if codec == 1 {
		if err := json.Unmarshal(data, inst); err != nil {
			return err
		}
	}
	return nil
}

func GetMethById(id uint16) string {
	return id2meth[id]
}

// define call enter point
func RegisterTransmitor(endpoint, method string, md metadata.MD, data []byte, codec uint16,
	callback func(proto.Message), opts ...grpc.DialOption) error {
	args := &TransmitArgs{
		Method:      method,
		Endpoint:    endpoint,
		MD:          md,
		Data:        data,
		Codec:       codec,
		EndCallback: callback,
		Opts:        opts,
	}
	if len(args.Method) < 1 || len(args.Endpoint) < 1 || len(args.MD) < 1 || args.EndCallback == nil {
		return errors.New("transmit args empty")
	}

	parseMethod := func(method string) (string, string, string, error) {
		method = strings.Trim(method, "/")
		dotIdx := strings.Index(method, ".")
		slashIdx := strings.Index(method, "/")
		if dotIdx < 1 || slashIdx < 1 || dotIdx > slashIdx {
			return "", "", "", errors.New("method must be type of 'package.ServiceName/Method'")
		}
		packageName := method[:dotIdx]
		serviceName := strings.Trim(method[dotIdx:slashIdx], ".")
		methodName := strings.Trim(method[slashIdx:], "/")
		return packageName, serviceName, methodName, nil
	}

	packageName, serviceName, _, err := parseMethod(method)
	if err != nil {
		return err
	}
	packageService := packageName + "." + serviceName
	if handler, ok := serviceMap[packageService]; ok {
		err := handler(args)
		return err
	}
	return errors.New("method not register yet")
}

// registor single service enter point

// *********************************************************************************
// 注册ImGate传输转换入口
// 上行
func register_Authorize_Transmitor(args *TransmitArgs) (err error) {
	ctx := context.Background()
	// ctx, _ := context.WithTimeout(ctx, 15*time.Second)
	ctx = metadata.NewOutgoingContext(ctx, args.MD)
	args.ctx = ctx
	//
	conn, err := grpc.Dial(args.Endpoint, args.Opts...)
	if err != nil {
		return err
	}

	defer conn.Close()

	client := NewAuthorizeClient(conn)

	handler, ok := transmit_Authorize_Map[args.Method]
	if !ok {
		return errors.New("method error")
	}
	res, err := handler(args, client)
	if err != nil {
		return err
	}
	args.EndCallback(res)
	return nil
}

// 注册Authorize/Login 传输方法入口
// 登录校验用户
// @transmit
// @target Authorize
func request_Authorize_Login(args *TransmitArgs, client AuthorizeClient) (proto.Message, error) {
	protoReq := &ImLoginRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.Login(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Authorize/GetUserInfo 传输方法入口
// 获得用户信息
// @transmit
// @target Authorize
func request_Authorize_GetUserInfo(args *TransmitArgs, client AuthorizeClient) (proto.Message, error) {
	protoReq := &GetUserInfoRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.GetUserInfo(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// *********************************************************************************
// 注册ImGate传输转换入口
// 上行
func register_Im_Transmitor(args *TransmitArgs) (err error) {
	ctx := context.Background()
	// ctx, _ := context.WithTimeout(ctx, 15*time.Second)
	ctx = metadata.NewOutgoingContext(ctx, args.MD)
	args.ctx = ctx
	//
	conn, err := grpc.Dial(args.Endpoint, args.Opts...)
	if err != nil {
		return err
	}

	defer conn.Close()

	client := NewImClient(conn)

	handler, ok := transmit_Im_Map[args.Method]
	if !ok {
		return errors.New("method error")
	}
	res, err := handler(args, client)
	if err != nil {
		return err
	}
	args.EndCallback(res)
	return nil
}

// 注册Im/Read 传输方法入口
// 已读
// @transmit
// @target Im
func request_Im_Read(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImReadRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.Read(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/Send 传输方法入口
// 发消息
// @transmit
// @target Im
func request_Im_Send(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImSendRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.Send(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/Get 传输方法入口
// 获得聊天记录
// @transmit
// @target Im
func request_Im_Get(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImGetRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.Get(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/Delete 传输方法入口
// 删除聊天会话
// @transmit
// @target Im
func request_Im_Delete(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImDelRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.Delete(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/UpdateConversation 传输方法入口
// 同步会话列表
// @transmit
// @target Im
func request_Im_UpdateConversation(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImUpdateConversationRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.UpdateConversation(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/Black 传输方法入口
// 设置黑名单
// @transmit
// @target Im
func request_Im_Black(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImBlockRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.Black(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/GetUnreadCount 传输方法入口
// 获取未读消息的数量
// @transmit
// @target Im
func request_Im_GetUnreadCount(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImGetUnreadCountRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.GetUnreadCount(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/GetBlockList 传输方法入口
// 获取黑名单列表
// @transmit
// @target Im
func request_Im_GetBlockList(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImGetBlockListRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.GetBlockList(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/SetRecvFactor 传输方法入口
// 设置接收条件
// @transmit
// @target Im
func request_Im_SetRecvFactor(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImSetRecvFactorRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.SetRecvFactor(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}

// 注册Im/GetRecvFactor 传输方法入口
// 获取接收条件
// @transmit
// @target Im
func request_Im_GetRecvFactor(args *TransmitArgs, client ImClient) (proto.Message, error) {
	protoReq := &ImGetRecvFactorRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.GetRecvFactor(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}
