// Code generated by protoc-gen-grpc-tcpway. DO NOT EDIT.
// source: proto/test.proto

/*
Package test is a tcp/ws proxy.

It translates protobuf/Json packet into gRPC APIs.
*/
package test

import (
	"context"
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// define func
type registerHandler func(args *transmitArgs) (err error)

type transmit_Test_Handler func(*transmitArgs, TestClient) (proto.Message, error)

type transmitArgs struct {
	Method      string
	Endpoint    string
	MD          metadata.MD
	Data        []byte
	Codec       uint16
	Opts        []grpc.DialOption
	EndCallback func(proto.Message)
	ctx         context.Context
}

var (
	transmit_Test_Map = map[string]transmit_Test_Handler{}

	serviceMap = map[string]registerHandler{}
)

func init() {
	// todo something missing

	transmit_Test_Map["test.Test/Send"] = request_Test_Send

	serviceMap["test.Test"] = register_Test_Transmitor

}

func decodeBytes(data []byte, codec uint16, inst proto.Message) error {
	if codec == 0 {
		if err := proto.Unmarshal(data, inst); err != nil {
			return err
		}
	} else if codec == 1 {
		if err := json.Unmarshal(data, inst); err != nil {
			return err
		}
	}
	return nil
}

// define call enter point
func RegisterTransmitor(endpoint, method string, md metadata.MD, data []byte, codec uint16,
	callback func(proto.Message), opts ...grpc.DialOption) error {
	args := &transmitArgs{
		Method:      method,
		Endpoint:    endpoint,
		MD:          md,
		Data:        data,
		Codec:       codec,
		EndCallback: callback,
		Opts:        opts,
	}
	if len(args.Method) < 1 || len(args.Endpoint) < 1 || len(args.MD) < 1 || len(args.Data) < 1 || args.EndCallback == nil {
		return errors.New("transmit args empty")
	}

	parseMethod := func(method string) (string, string, string, error) {
		method = strings.Trim(method, "/")
		dotIdx := strings.Index(method, ".")
		slashIdx := strings.Index(method, ".")
		if dotIdx < 1 || slashIdx < 1 || dotIdx > slashIdx {
			return "", "", "", errors.New("method must be type of 'package.ServiceName/Method'")
		}
		packageName := method[:dotIdx]
		serviceName := method[dotIdx:slashIdx]
		methodName := method[slashIdx:]
		return packageName, serviceName, methodName, nil
	}

	packageName, serviceName, _, err := parseMethod(method)
	if err != nil {
		return err
	}
	packageService := packageName + "." + serviceName
	if handler, ok := serviceMap[packageService]; ok {
		err := handler(args)
		return err
	}
	return errors.New("method not register yet")
}

// registor single service enter point

// *********************************************************************************
// 注册Test传输转换入口
func register_Test_Transmitor(args *transmitArgs) (err error) {
	ctx, _ := context.WithTimeout(context.Background(), 15*time.Second)
	ctx = metadata.NewOutgoingContext(ctx, args.MD)
	args.ctx = ctx
	//
	conn, err := grpc.Dial(args.Endpoint, args.Opts...)
	if err != nil {
		return err
	}

	defer conn.Close()

	client := NewTestClient(conn)

	handler, ok := transmit_Test_Map[args.Method]
	if !ok {
		return errors.New("method error")
	}
	res, err := handler(args, client)
	if err != nil {
		return err
	}
	args.EndCallback(res)
	return nil
}

// 注册Test/Send 传输方法入口
func request_Test_Send(args *transmitArgs, client TestClient) (proto.Message, error) {
	protoReq := &FooRequest{}

	if err := decodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, err
	}

	reply, err := client.Login(args.ctx, protoReq)
	if err != nil {
		return nil, err
	}
	return reply, nil
}
